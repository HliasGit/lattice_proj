#include <iostream>
#include <vector>
#include <chrono>
#include <stack>
#include <sstream>

#include "parser.hpp"

struct Node {
  int depth; // depth in the tree
  std::vector<int> value;// configration for that node
  bool* domain;
  int *lenDom;
  
  Node(size_t N, bool* domain, int *lenDom): depth(0), value(N), domain(domain), lenDom(lenDom){
    for (int i = 0; i < N; i++) {
      value[i] = 0;
    }
  }
  Node(const Node&) = default;
  Node(Node&&) = default;
  Node() = default;

  public:

  void printLenDom(){
    for(int i = 0; i < value.size(); i++){
      std::cout << lenDom[i] << " ";
    }
    std::cout << std::endl;
  }

  int getindexes(int variable){
    if(variable == -1)
      return 0;
    else
      return lenDom[variable];
  }

  bool getAvail(int index)
  {
    return domain[index];
  }

  void turnToFalse(int index)
  {
    domain[index] = false;
  }

  void printValue(){
    for(int i = 0; i < value.size(); i++){
      std::cout << value[i] << " ";
    }
    std::cout << std::endl;
  }

};

// Function to generate arrays based on upper bounds
int generateArrays(int* ub, size_t size, int *lenDom) {
    std::vector<std::vector<int>> arrays(size);
    for (size_t i = 0; i < size; ++i) {
        arrays[i].resize(ub[i] + 1);
        for (int j = 0; j <= ub[i]; ++j) {
            arrays[i][j] = j;
        }
    }
    lenDom[0] = arrays[0].size();
    int sum = arrays[0].size();

    for(int i = 1; i < size; i++){
        lenDom[i] = lenDom[i-1] + arrays[i].size();
        sum += arrays[i].size();
    }
    return sum;
}

void generateDomain(int* ub, size_t size, bool* domain, int domainSize) {
    for (size_t i = 0; i < domainSize;++i) {
      domain[i] = true;
    }
}


bool isSafe(const std::vector<int>& values, const int j, int **C, const int depth)
{
  for (int i = 0; i < depth; i++) {
    if (C[i][depth] == 1 && values[i] == j) {
      return false;
    }
  }
  return true;
}

// evaluate a given node (i.e., check its board configuration) and branch it if it is valid
// (i.e., generate its child nodes.)
void evaluate_and_branch(Node& parent, std::stack<Node>& pool, size_t& tree_loc, size_t& num_sol, int **C, int &count)
{
  int depth = parent.depth;
  int N = parent.value.size();

  int j;
  // if the given node is a leaf, then update counter and do nothing
  if (depth == N) {
    num_sol++;
  }

  // if the given node is not a leaf, then update counter and evaluate/branch it
  else {
    for(j = parent.getindexes(depth-1); j < parent.getindexes(depth); j++){
      int j_rel = j-parent.getindexes(depth-1);
      // print j_rel
      std::cout << "j_rel for j " << j_rel << ", " << j << ", depth: " << depth << std::endl;
      // if(depth==1){
      // std::cout << "AAAA" << isSafe(parent.value, j, C, parent.depth) << std::endl;
      // return;}
      if (isSafe(parent.value, j_rel, C, parent.depth)) {
        Node child(parent);
        //std::swap(child.value[depth], child.value[j]);
        for (int i=depth; i<N; i++){
          if (C[i][depth] == 1) {
            child.turnToFalse(j_rel);
          }
        }
        child.value[depth] = j_rel;
        child.depth++;
        std::cout << std::endl;
        std::cout << "Now evaluate: " << std::endl;
        child.printValue();
        pool.push(std::move(child));
        tree_loc++;
      }
    }
  }
}


int main(int argc, char** argv) {

    // Check if the number of arguments is correct
    if (argc != 2) {
        std::cout << "usage: " << argv[0] << " elements " << std::endl;
        exit(1);
    }


    // number of elements to treat
    size_t N = std::stoll(argv[1]);
    std::cout << "Solving " << N << " sized generic problem\n" << std::endl;

    // use data generated by the parser
    bool* domain;
    int domainSize = 0;
    int lenDom[N];

    int **C;

    Data data;
    std::ostringstream filename;
    filename << "pco_" << N << ".txt";

    // Use the dynamically constructed filename in the data.read_input function call
    if (data.read_input(filename.str().c_str())) {
        // print the number of elements
        std::cout << "Number of elements: " << data.get_n() << std::endl;
        N = data.get_n();

        // get the upper bound
        int *ub = data.get_u();
        domainSize = generateArrays(ub, N, lenDom);

        std::cout << "Domain size: " << domainSize << std::endl;

        domain = new bool[domainSize];

        generateDomain(ub, N, domain, domainSize);

        // get the constraint matrix
        C = data.get_C();

    } else {
        std::cerr << "Error while reading the file" << std::endl;
        return 1;
    }


    // initialization of the root node (the board configuration where no queen is placed)
    Node root(N, domain, lenDom);

    // initialization of the pool of nodes (stack -> DFS exploration order)
    std::stack<Node> pool;
    pool.push(std::move(root));

    // statistics to check correctness (number of nodes explored and number of solutions found)
    size_t exploredTree = 0;
    size_t exploredSol = 0;

    // beginning of the Depth-First tree-Search
    auto start = std::chrono::steady_clock::now();

    int count = 0;

    while (pool.size() != 0) {
        // get a node from the pool
        Node currentNode(std::move(pool.top()));
        pool.pop();

        // check the board configuration of the node and branch it if it is valid.
        evaluate_and_branch(currentNode, pool, exploredTree, exploredSol, C, count);
    }

    auto end = std::chrono::steady_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);

    //std::cout << "Count " << count << std::endl;

    // outputs
    std::cout << "Time taken: " << duration.count() << " milliseconds" << std::endl;
    std::cout << "Total solutions: " << exploredSol << std::endl;
    std::cout << "Size of the explored tree: " << exploredTree << std::endl;

    return 0;
}